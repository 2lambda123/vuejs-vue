# 响应式原理

> 数据到DOM的变化

**响应式原理概述**
- 通过`Object.defineProperty()`将`this.$data`下面的数据递归转换成响应式对象；
- 在`getter`中收集依赖，对象在`setter`中触发依赖，数组则是通过拦截数组的原型方法触发依赖；
- 在`Dep`（订阅者）中对依赖进行统一管理，如添加依赖、删除依赖、通知依赖等；
- 依赖可能是模板，也可能是用户定义的`watch`，依赖通过读取数据的`getter`，将自己收集到`Dep`中，等到数据发生改变时，再触发依赖，更新DOM或者执行`$watch`的回调函数；

## 1. Observer变化侦测

### 1-1. 对象的响应式原理-Object.defineProperty()
- get
  - 收集依赖：`dep.depend()`，保存进Dep数组；
  - `value.__ob__.dep.depend()`；
- set
  - 更新数据，循环Dep触发依赖：`dep.notify()`；
- 通过`observe()`即`new Observer()`实现对象递归侦测；
- 对象的依赖保存在`defineReactive()`方法的`new dep()`中；

### 1-2. 数组的响应式原理
**使用拦截器覆盖原生的原型方法**
- `arrayMethods = Object.create(Array.prototype)`；
- 重写了7个数组方法：`push`、`pop`、`unshift`、`shift`、`splice`、`sort`和`reverse`；
- `value.__proto__ = arrayMethods`；
- 数组在`getter`中收集依赖；
- 数组在拦截器中触发依赖；
- 数组的依赖存储在`arr.__ob__.dep`中；

### 1-3. 一些问题
1. 问：`__ob__ `的作用是什么；
答：(1). 标记数据是否已经被转换成了响应式对象（保证同一数据只能被侦听一次）；
(2). 数组拦截器可以通过`this.__ob__.dep`访问到保存的依赖，从而通知`Watcher`；
<hr/>

## 2. Dep管理依赖
- 收集依赖：`dep.depend()`
- 触发依赖：`dep.notify()`

<hr/>

## 3. Watcher依赖

### 3-1. 依赖有哪些
- 组件更新；
- 用户定义的`$watch`；
- 计算属性`computed`里面的`watch`；

### 3-2. 收集依赖过程
- `pushTarget(this)` => `Dep.target = this`将watcher赋值到Dep.target；
- `value = this.getter.call(vm, vm)`读取value的getter，`this.getter`对应的是`updateComponent()`函数
- 触发`getter`后，进行依赖收集，`dep.depend()` => `Dep.target.addDep(this)` => `Dep.target.newDepIds.add(dep.id)`、`Dep.target.newDeps.push(dep)`、`dep.addSub(this)`；

### 3-3. 派发更新

更新的内容包括：视图更新和执行`$watch`的回调函数。

- setter中执行`observe(newVal)`，把新设置的值变成响应式对象，`dep.notify()`；
- 循环`subs`，触发`subs[i].update()`；
- 执行`queueWatcher()`，将`watcher`放进队列里，如果正在执行队列中的某一个`watcher`，则将新插入的`watcher`放在正在执行`watcher`的后面；
- 执行`watcher.run()`，设置新的`value`，执行`$watch`的`cb()`；

## 4. 响应式的缺陷

### 4-1. 对象的缺陷
- `Object.defineProperty()`只能监测到对象的变化，不能监测到对象新增属性和删除属性

### 4-2. 数组的缺陷
- 直接改变数组的索引，不会监测到数组的变化；
- 直接改变数组的长度，不会监测到数组的变化；

## 5. 总结

Observer、Dep、Watcher关系图如下：
![响应式原理](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8709b074689846fe9360ab9042c27510~tplv-k3u1fbpfcp-watermark.image)